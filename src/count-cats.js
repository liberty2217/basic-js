const CustomError = require("../extensions/custom-error");

module.exports = function countCats( matrix ){
  
  let result = 0;

  for (let i = 0; i < matrix.length; i = i + 1){
    if (matrix[i] === '^^'){
    result = result + 1;
    }
  }
  return result
  
}



// matrix[i] === matrix

// ### **Сосчитай котов!**

// Ваша задача — сосчитать котов, спрятавшихся на заднем дворе (представленном в виде двумерного массива, `Array`). Коты прячутся хорошо, но их **ушки** (`"^^"`) видны очень хорошо. Ваша задача — реализовать функцию `countCats(backyard)`, которая сосчитает котов. Удачи!

// Число найденных котов должно иметь тип `number`. Если коты не найдены, функция должна вернуть `0`.

// Например:

// `countCats([
//     [0, 1, '^^'],
//     [0, '^^', 2],
//     ['^^', 1, 2]
//   ]) => 3`

// Напишите ваш код в `src/count-cats.js`.

















// module.exports = function countCats( matrix ){
//   return matrix.reduce( (totalEars, currentValue) => totalEars + currentValue.filter( currentValueFilter => currentValueFilter === '^^').length, 0);
// }
// // Шаг 1) Используем метод .reduce() для данного массива, чтобы вывести финальное единое значение.

// Метод .reduce() - принимает два параметра:

//        1. callbackFunction. Принимает 4 аргумента:
//      (accumulator, currentValue, [index [array]])

//        2. [initialValue]


// Шаг 2) вставляем первый параметр - сallBackFunction 



// Шаг 3) Начинаем реализовывать callbackFunction в виде стрелочной функции и начинаем с ее аргументов:

//        1. Задаем два аргумента (нужно как минимум 2) для нашей стрелочной функции:
              
//            А) Задаем первый аргумент - catsNumber - в нашем случае он будет выступать в роли accumulator, так как он стоит первый. То есть он сохраняет наши значения в себя (как в переменную, по которой происходит итерация - итерация по причине использования метода reduce

//            (Напомним, что всего по порядку аргументов: (accumulator, currentValue, [index [array]]) - поэтому первая переменная будет всегда - accumulator. Вторая всегда - currentValue и так далее)

//            Б) Задаем второй аргумент - currentValue - так как он стоит вторым, после catsNumber, он будет выступать в роли currentValue)


// Таким образом, мы объявили конкретные установленные аргументы нашей функции (стрелочного типа) конкретно для метода .reduce(). Но пока не указали тело функции - то есть то, что будет выполняться в этой функции. Сделали все это мы следующим образом: 


//                 (totalEars, currentValue) => 



// Шаг 4) Пишем тело функции после указания ее параметров, где она выдает конченый результат return в виде операции: 

//  catsNumber + currentValue.filter( currentValueFilter => currentValueFilter === '^^').length, 0);



// Объяснение currentValue.filter ( item => item === '^^).length 

// .filter() - это метод, который создает новый массив со всеми элементами, прошедшими проверку условия, задаваемую в передаваемой функции.

// .filter имеет параметры:

//  Обязательный (один) параметр:
    
//              А) callbackFunction (обязательный) - Функция (фильтрации - сама сущность метода .filter), которая будет вызвана для каждого элемента массива. ВАЖНО! - если, функция возвращает true, то элемент остаётся в массиве, если false, то удаляется.

//              Б) thisValue (опционально) - значения для функции, используемое в качестве 'this'


// Для callbackFunction (метода .filter) есть 3 аргумента:

//  1) currentValue (обязательный) - значение текущего элемента
//  2) index (опциональный) - индекс текущего элемента в массиве
//  3) arr (опциональный) - массив, к которому относится текущий элемент)

// то есть наш callbackFunction (стрелочного типа) (метода .filter) это 

// (currentValueFilter) => currentValueFilter === '^^';
// но мы его сократили до currentValue.filter( item => item === '^^')

// то есть мы можем заменить название currentValueFilter на item - разницы никакой. так как оба они представляют собой первый обязательный аргумент функции - currentValue, так как они стоят в самом начале по порядку. Просто некоторые названия осознанные и понятные (currentValueFilter), а некоторые (item) - непонятные.




// В нашем случае мы использовали метод .filter() вместе с каждым итерируемым элементом внутри нашего array, то есть с его currentValue. 

// Однако (этот момент не совсем могу пояснить), Мы также использовали свойство .length - это необходимо, на мой взгляд (запустили ран тест), для того, чтобы в случае попадания нецифровых, нестроковых значений, вроде NaN, undefined,  - мы также могли их проитерировать на равенство их '^^'


// Таким образом, мы задали методу .filter() - его функцию (сущность метода) следующим образом:

// Если наш каждый итерируемый в .reduce() методе элемент равен '^^' (true), то оставь его в массиве, если он не равен '^^' (false), то удали (в значении "отфильтруй") его. 






// accumulator - Аккумулятор, аккумулирующий значение, которое возвращает функция callback после посещения очередного элемента, либо значение initialValue, если оно предоставлено (смотрите пояснения ниже).

// currentValue - текущий обрабатываемый элемент массива

